function [warnings] = TAinfoFileWrite(filename,parameters,varargin)
% TAINFOFILEWRITE Write Info files of TA spectra.
%
% Usage
%   TAinfoFileWrite(filename,parameters)
%   [warnings] = TAinfoFileWrite(filename,parameters)
%
% filename   - string
%              Valid filename (for a TA Info file)
% parameters - struct
%              structure containing parameters to write to the TA Info file
%
%              Either a structure as read with TAinfoFileParse or the
%              parameters structure of a TA toolbox dataset
%
% warnings   - cell array of strings
%              empty if there are no warnings
%

% (c) 2012, Till Biskup
% 2012-04-05

% If called without parameter, do something useful: display help
if ~nargin && ~nargout
    help TAinfoFileWrite
    return;
end

% Parse input arguments using the inputParser functionality
p = inputParser;   % Create an instance of the inputParser class.
p.FunctionName = mfilename; % Function name to be included in error messages
p.KeepUnmatched = true; % Enable errors on unmatched arguments
p.StructExpand = true; % Enable passing arguments in a structure

p.addRequired('filename', @(x)ischar(x));
p.addRequired('parameters', @(x)isstruct(x));
p.addParamValue('overwrite',logical(false),@islogical);
%p.addOptional('command','',@(x)ischar(x));
p.parse(filename,parameters,varargin{:});

warnings = cell(0);

% Define identifierString for Info File format
identifierString = 'TA Info file -  v. 0.2d (2012-03-31)';

% Define length of parameter field
fieldNameLength = 25;

try
    % If there is no filename specified, open file selection dialogue
    if isempty(filename)
        [FileName,PathName] = uiputfile('*.info',...
            'Select filename for info file');
        filename = fullfile(PathName,FileName);
    end
    % If filename exists and overwrite set to false, ask user to overwrite
    if  exist(filename,'file') && ~p.Results.overwrite
        while 1
            button = questdlg(...
                sprintf('File\n  %s\n exists already. Overwrite?',filename),...
                'File exists...',...
                'Yes','No','Cancel','No');
            switch lower(button)
                case 'no'
                    [FileName,PathName] = uiputfile('*.info',...
                        'Select filename for info file');
                    if ~isempty(FileName) && FileName ~= 0;
                        filename = fullfile(PathName,FileName);
                        break;
                    end
                case 'cancel'
                    return;
                otherwise
                    break;
            end
        end
    end
    
    % Assemble file contents in cell array
    fileContents = cell(0);
    
    % First line of file contents is the identifier string
    fileContents{1} = identifierString;
    % Second line of file is an empty line
    fileContents{2} = '';

    % Block names are defined in a cell array.
    blockNames = {...
        'GENERAL' ...
        'SAMPLE' ...
        'TRANSIENT' ...
        'SPECTROGRAPH' ...
        'DETECTION' ...
        'RECORDER' ...
        'PUMP' ...
        'PROBE' ...
        'TEMPERATURE' ...
        'MFE' ...
        'TIME PROFILES' ...
        'COMMENT' ...
        };
    for k=1:length(blockNames)
        blocks.(lower(strrep(blockNames{k},' ',''))) = blockNames{k};
    end
    
    parametersFieldNames = fieldnames(parameters);
    
    if any(strcmpi(parametersFieldNames,'parameters'))
        parameters = mapToDataStructure(parameters);
        parametersFieldNames = fieldnames(parameters);
    end
    
    for k=1:length(parametersFieldNames)
        if isstruct(parameters.(parametersFieldNames{k}))
            if ~isempty(fieldnames(parameters.(parametersFieldNames{k})))
                fileContents{end+1} = blocks.(parametersFieldNames{k}); %#ok<AGROW>
                blockFieldNames = ...
                    fieldnames(parameters.(parametersFieldNames{k}));
                for m=1:length(blockFieldNames)
                    blockFieldName = ...
                        regexprep([blockFieldNames{m} ':'],'([A-Z])',' $1');
                    blockFieldName(1) = upper(blockFieldName(1));
                    blockFieldName(end+1:fieldNameLength)=' ';
                    if iscell(parameters.(parametersFieldNames{k}).(blockFieldNames{m}))
                        fileContents{end+1} = sprintf('%s%s',...
                            blockFieldName,...
                            num2str(...
                            parameters.(parametersFieldNames{k}).(blockFieldNames{m}){1})...
                            ); %#ok<AGROW>
                        if length(parameters.(parametersFieldNames{k}).(blockFieldNames{m})) > 1
                            fileContents = [ fileContents ...
                                cellfun(@(x)sprintf(' %s',x),...
                                parameters.(parametersFieldNames{k}).(blockFieldNames{m})(2:end),...
                                'UniformOutput',false)
                                ]; %#ok<AGROW>
                        end
                    else
                        fileContents{end+1} = sprintf('%s%s',...
                            blockFieldName,...
                            num2str(...
                            parameters.(parametersFieldNames{k}).(blockFieldNames{m}))...
                            ); %#ok<AGROW>
                    end
                end
                fileContents{end+1} = ''; %#ok<AGROW>
            end
        else
            fileContents{end+1} = blocks.(parametersFieldNames{k}); %#ok<AGROW>
            fileContents = ...
                [fileContents parameters.(parametersFieldNames{k})]; %#ok<AGROW>
            fileContents{end+1} = ''; %#ok<AGROW>
        end
    end
    
    % Write content of the cell array "fileContents" to file
    fh = fopen(filename,'w');
    cellfun(@(x)fprintf(fh,'%s\n',x),fileContents);
    fclose(fh);

catch exception
    throw(exception);
end

end


% MAPTODATASTRUCTURE Internal function mapping the parameters read to the
%                    TA toolbox data structure.
%
% parameter     - struct
%                 Structure containing the parsed contents of the Info file
%
% dataStructure - Structure containing the fields of the TA toolbox data
%                 structure with mapped information from the input
%
function dataStructure = mapToDataStructure(parameters)
try
    dataStructure = struct();
    
    % Cell array correlating struct fieldnames read from the metafile and
    % from the toolbox data structure.
    % The first entry contains the fieldname generated while parsing the
    % metafile, the second entry contains the corresponding field name of
    % the toolbox data structure struct. The third parameter, 
    % finally, tells the program how to parse the corresponding entry.
    % Here, "numeric" means that the numbers of the field should be treated
    % as numbers, "copy" means to just copy the field unaltered, and
    % "valueunit" splits the field in a numeric value and a string
    % containing the unit.
    matching = {...
        % GENERAL
        % Fields handled separately below: date, timeStart, timeEnd
        'general.filename','file.name','copy';...
        'general.operator','parameters.operator','copy';...
        'general.label','label','copy';...
        'general.spectrometer','parameters.spectrometer.name','copy';...
        'general.software','parameters.spectrometer.software','copy';...
        'general.runs','parameters.runs','numeric';...
        'general.shotRepetitionRate','parameters.shotRepetitionRate','valueunit';...
        % SAMPLE
        'sample.name','sample.name','copy';...
        'sample.description','sample.description','copy';...
        'sample.preparation','sample.preparation','copy';...
        'sample.cuvette','sample.cuvette','copy';...
        % TRANSIENT
        'transient.points','parameters.transient.points','numeric';...
        'transient.triggerPosition','parameters.transient.triggerPosition','numeric';...
        % transient length needs special handling
        % SPECTROGRAPH
        'spectrograph.type','parameters.spectrograph.type','copy';...
        'spectrograph.model','parameters.spectrograph.model','copy';...
        'spectrograph.apertureFront','parameters.spectrograph.aperture.front','valueunit';...
        'spectrograph.apertureBack','parameters.spectrograph.aperture.back','valueunit';...
        % DETECTION
        'detection.type','parameters.detection.type','copy';...
        'detection.model','parameters.detection.model','copy';...
        'detection.powerSupply','parameters.detection.powersupply','copy';...
        'detection.impedance','parameters.detection.impedance','valueunit';...
        'detection.timeConstant','parameters.detection.timeConstant','valueunit';...
        % RECORDER
        'recorder.model','parameters.recorder.model','copy';...
        'recorder.averages','parameters.recorder.averages','numeric';...
        'recorder.sensitivity','parameters.recorder.sensitivity','valueunit';...
        'recorder.bandwidth','parameters.recorder.bandwidth','valueunit';...
        'recorder.timeBase','parameters.recorder.timeBase','valueunit';...
        'recorder.coupling','parameters.recorder.coupling','copy';...
        % PUMP
        'pump.type','parameters.pump.type','copy';...
        'pump.model','parameters.pump.model','copy';...
        'pump.wavelength','parameters.pump.wavelength','valueunit';...
        'pump.power','parameters.pump.power','valueunit';...
        'pump.repetitionRate','parameters.pump.repetitionRate','valueunit';
        'pump.tunableType','parameters.pump.tunable.type','copy';...
        'pump.tunableModel','parameters.pump.tunable.model','copy';...
        'pump.tunableDye','parameters.pump.tunable.dye','copy';...
        % PROBE
        'probe.type','parameters.probe.type','copy';...
        'probe.model','parameters.probe.model','copy';...
        % wavelength start, stop, step has to be dealt with separately
        'probe.wavelengthSequence','parameters.probe.wavelength.sequence','copy';...
        'probe.power','parameters.probe.power','valueunit';...
        'probe.filter','parameters.probe.filter','copy';...
        'probe.background','parameters.probe.background','copy';...
        % TEMPERATURE
        'temperature.temperature','parameters.temperature','valueunit';...
        'temperature.controller','parameters.temperature.controller','copy';...
        'temperature.cryostat','parameters.temperature.cryostat','copy';...
        'temperature.cryogen','parameters.temperature.cryogen','copy';...
        % MFE
        'mfe.field','parameters.MFE.field','valueunit';...
        'mfe.coilType','parameters.MFE.coils.type','copy';...
        'mfe.coilModel','parameters.MFE.coils.model','copy';...
        'mfe.powerSupply','parameters.MFE.powerSupply','copy';...
        'mfe.gaussmeter','parameters.MFE.gaussmeter','copy';...
        % TIME PROFILES
        % Has to be dealt with separately
        % COMMENT
        'comment','comment','copy';...
        };
    
    for k=1:length(matching)
        switch matching{k,3}
            case 'numeric'
                dataStructure = setCascadedField(dataStructure,...
                    matching{k,1},...
                    num2str(getCascadedField(parameters,matching{k,2})));
            case 'valueunit'
                dataStructure = setCascadedField(dataStructure,...
                    matching{k,1},...
                    sprintf('%s %s',...
                    num2str(getCascadedField(parameters,[matching{k,2} '.value'])),...
                    getCascadedField(parameters,[matching{k,2} '.unit'])...
                    ));
            case 'copy'
                dataStructure = setCascadedField(dataStructure,...
                    matching{k,1},...
                    getCascadedField(parameters,matching{k,2}));
        end
    end
    
    % Handle the special case of date and time that get splitted into two
    % fields
    dataStructure.general.date = ...
        datestr(datenum(parameters.parameters.date.start),'yyyy-mm-dd');
    dataStructure.general.timeStart = ...
        datestr(datenum(parameters.parameters.date.start),'HH:MM:SS');
    dataStructure.general.timeEnd = ...
        datestr(datenum(parameters.parameters.date.end),'HH:MM:SS');
    % Handle the special case of wavelength start, stop, step (unit!)
    matchingWavelengths = {...
        'probe.wavelengthStart','parameters.probe.wavelength.start'; ...
        'probe.wavelengthStop','parameters.probe.wavelength.stop'; ...
        'probe.wavelengthStep','parameters.probe.wavelength.step'; ...
        };
    for k=1:length(matchingWavelengths)
        dataStructure = setCascadedField(dataStructure,...
            matchingWavelengths{k,1},...
            sprintf('%s %s',...
            num2str(getCascadedField(parameters,matchingWavelengths{k,2})),...
            parameters.parameters.probe.wavelength.unit));
    end
    % Handle the special case of transient length
    dataStructure.transient.length = sprintf('%s %s',...
        num2str(parameters.parameters.transient.length),...
        parameters.parameters.transient.unit);
    
    % TODO: Handle timeProfiles, especially the filters at different
    %       wavelengths
catch exception
    throw(exception);
end

end

% --- Get field of cascaded struct
function value = getCascadedField (struct, fieldName)
    try
        % Get number of "." in fieldName
        nDots = strfind(fieldName,'.');
        if isempty(nDots)
            if isfield(struct,fieldName)
                value = struct.(fieldName);
            else
                value = '';
            end
        else
            struct = struct.(fieldName(1:nDots(1)-1));
            value = getCascadedField(...
                struct,...
                fieldName(nDots(1)+1:end));
        end
    catch exception
        disp(fieldName);
        disp(struct);
        throw(exception);
    end 
end

% --- Set field of cascaded struct
function struct = setCascadedField (struct, fieldName, value)
    % Get number of "." in fieldName
    nDots = strfind(fieldName,'.');
    if isempty(nDots)
        struct.(fieldName) = value;
    else
        if ~isfield(struct,fieldName(1:nDots(1)-1))
            struct.(fieldName(1:nDots(1)-1)) = [];
        end
        innerstruct = struct.(fieldName(1:nDots(1)-1));
        innerstruct = setCascadedField(...
            innerstruct,...
            fieldName(nDots(1)+1:end),...
            value);
        struct.(fieldName(1:nDots(1)-1)) = innerstruct;
    end
end